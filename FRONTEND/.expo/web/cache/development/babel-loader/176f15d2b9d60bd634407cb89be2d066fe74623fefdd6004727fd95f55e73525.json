{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport React, { createContext, useContext, useState, useEffect, useCallback } from 'react';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport AppState from \"react-native-web/dist/exports/AppState\";\nimport { useNetwork } from \"./NetworkContext\";\nimport { useDatabase } from \"./DatabaseContext\";\nimport { useAuth } from \"./AuthContext\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport var SYNC_STATUS = {\n  IDLE: 'idle',\n  SYNCING: 'syncing',\n  SUCCESS: 'success',\n  ERROR: 'error'\n};\nvar SyncContext = createContext({\n  syncStatus: SYNC_STATUS.IDLE,\n  lastSyncTime: null,\n  pendingSyncItems: 0,\n  syncNow: function () {\n    var _syncNow = _asyncToGenerator(function* () {});\n    function syncNow() {\n      return _syncNow.apply(this, arguments);\n    }\n    return syncNow;\n  }(),\n  syncStatusDetails: {},\n  resetSyncStatus: function resetSyncStatus() {},\n  updateSyncItem: function () {\n    var _updateSyncItem = _asyncToGenerator(function* () {});\n    function updateSyncItem() {\n      return _updateSyncItem.apply(this, arguments);\n    }\n    return updateSyncItem;\n  }()\n});\nexport var useSync = function useSync() {\n  return useContext(SyncContext);\n};\nexport var SyncProvider = function SyncProvider(_ref) {\n  var children = _ref.children;\n  var _useNetwork = useNetwork(),\n    isConnected = _useNetwork.isConnected,\n    isInternetReachable = _useNetwork.isInternetReachable,\n    connectionQuality = _useNetwork.connectionQuality;\n  var _useDatabase = useDatabase(),\n    executeQuery = _useDatabase.executeQuery,\n    transaction = _useDatabase.transaction,\n    isDbReady = _useDatabase.isDbReady;\n  var _useAuth = useAuth(),\n    isAuthenticated = _useAuth.isAuthenticated;\n  var _useState = useState(SYNC_STATUS.IDLE),\n    _useState2 = _slicedToArray(_useState, 2),\n    syncStatus = _useState2[0],\n    setSyncStatus = _useState2[1];\n  var _useState3 = useState({}),\n    _useState4 = _slicedToArray(_useState3, 2),\n    syncStatusDetails = _useState4[0],\n    setSyncStatusDetails = _useState4[1];\n  var _useState5 = useState(null),\n    _useState6 = _slicedToArray(_useState5, 2),\n    lastSyncTime = _useState6[0],\n    setLastSyncTime = _useState6[1];\n  var _useState7 = useState(0),\n    _useState8 = _slicedToArray(_useState7, 2),\n    pendingSyncItems = _useState8[0],\n    setPendingSyncItems = _useState8[1];\n  var _useState9 = useState(3600000),\n    _useState0 = _slicedToArray(_useState9, 2),\n    syncInterval = _useState0[0],\n    setSyncInterval = _useState0[1];\n  var _useState1 = useState(false),\n    _useState10 = _slicedToArray(_useState1, 2),\n    syncInProgress = _useState10[0],\n    setSyncInProgress = _useState10[1];\n  var _useState11 = useState(false),\n    _useState12 = _slicedToArray(_useState11, 2),\n    syncOnWifiOnly = _useState12[0],\n    setSyncOnWifiOnly = _useState12[1];\n  useEffect(function () {\n    if (isDbReady) {\n      loadSyncSettings();\n      countPendingSyncItems();\n    }\n  }, [isDbReady]);\n  var loadSyncSettings = useCallback(_asyncToGenerator(function* () {\n    try {\n      var _result$rows;\n      var result = yield executeQuery(\"SELECT key, value FROM settings WHERE key IN ('last_sync', 'sync_interval', 'sync_wifi_only');\");\n      if ((result == null ? void 0 : (_result$rows = result.rows) == null ? void 0 : _result$rows.length) > 0) {\n        for (var i = 0; i < result.rows.length; i++) {\n          var item = result.rows.item(i);\n          switch (item.key) {\n            case 'last_sync':\n              setLastSyncTime(parseInt(item.value, 10) || null);\n              break;\n            case 'sync_interval':\n              setSyncInterval(parseInt(item.value, 10) || 3600000);\n              break;\n            case 'sync_wifi_only':\n              setSyncOnWifiOnly(item.value === 'true');\n              break;\n            default:\n              break;\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error loading sync settings:', error);\n    }\n  }), [executeQuery, isDbReady]);\n  var countPendingSyncItems = useCallback(_asyncToGenerator(function* () {\n    if (!isDbReady) return;\n    try {\n      var pendingItemsCount = yield AsyncStorage.getItem('@pending_sync_count');\n      if (pendingItemsCount) {\n        setPendingSyncItems(parseInt(pendingItemsCount, 10));\n      } else {\n        var _result$rows2;\n        var result = yield executeQuery(\"SELECT COUNT(*) as count FROM sync_queue WHERE status = 'pending';\");\n        if ((result == null ? void 0 : (_result$rows2 = result.rows) == null ? void 0 : _result$rows2.length) > 0) {\n          var count = result.rows.item(0).count;\n          setPendingSyncItems(count);\n          yield AsyncStorage.setItem('@pending_sync_count', count.toString());\n        }\n      }\n    } catch (error) {\n      console.error('Error counting pending sync items:', error);\n    }\n  }), [executeQuery, isDbReady]);\n  useEffect(function () {\n    var handleAppStateChange = function handleAppStateChange(nextAppState) {\n      if (nextAppState === 'active') {\n        countPendingSyncItems();\n      }\n    };\n    var appStateSubscription = AppState.addEventListener('change', handleAppStateChange);\n    return function () {\n      appStateSubscription.remove();\n    };\n  }, [countPendingSyncItems]);\n  var syncNow = useCallback(_asyncToGenerator(function* () {\n    if (syncInProgress || !isDbReady || !isAuthenticated) return false;\n    if (syncOnWifiOnly && connectionQuality !== 'excellent') {\n      console.log('Sync aborted: WiFi-only mode is active and not on WiFi');\n      setSyncStatusDetails({\n        message: 'Sync requires WiFi connection',\n        error: 'wifi_required'\n      });\n      return false;\n    }\n    if (!isConnected || !isInternetReachable) {\n      console.log('Sync aborted: No internet connection');\n      setSyncStatusDetails({\n        message: 'No internet connection',\n        error: 'no_connection'\n      });\n      return false;\n    }\n    try {\n      var _pendingItems$rows;\n      setSyncInProgress(true);\n      setSyncStatus(SYNC_STATUS.SYNCING);\n      setSyncStatusDetails({\n        message: 'Starting synchronization...'\n      });\n      var pendingItems = yield executeQuery(\"SELECT * FROM sync_queue WHERE status = 'pending' ORDER BY created_at ASC LIMIT 100;\");\n      if ((pendingItems == null ? void 0 : (_pendingItems$rows = pendingItems.rows) == null ? void 0 : _pendingItems$rows.length) === 0) {\n        var _now = Date.now();\n        yield executeQuery(\"UPDATE settings SET value = ?, updated_at = ? WHERE key = 'last_sync';\", [_now.toString(), _now]);\n        setLastSyncTime(_now);\n        setSyncStatus(SYNC_STATUS.SUCCESS);\n        setSyncStatusDetails({\n          message: 'Sync completed successfully (no changes)'\n        });\n        return true;\n      }\n      var successCount = 0;\n      var errorCount = 0;\n      for (var i = 0; i < pendingItems.rows.length; i++) {\n        var item = pendingItems.rows.item(i);\n        setSyncStatusDetails({\n          message: \"Syncing item \" + (i + 1) + \" of \" + pendingItems.rows.length\n        });\n        try {\n          var syncResult = yield mockSyncItem(item);\n          if (syncResult.success) {\n            yield executeQuery(\"UPDATE sync_queue SET status = 'synced', updated_at = ? WHERE id = ?;\", [Date.now(), item.id]);\n            successCount++;\n          } else {\n            yield executeQuery(\"UPDATE sync_queue SET attempts = attempts + 1, updated_at = ? WHERE id = ?;\", [Date.now(), item.id]);\n            errorCount++;\n          }\n        } catch (error) {\n          console.error('Error syncing item:', item.id, error);\n          errorCount++;\n        }\n      }\n      var now = Date.now();\n      yield executeQuery(\"UPDATE settings SET value = ?, updated_at = ? WHERE key = 'last_sync';\", [now.toString(), now]);\n      setLastSyncTime(now);\n      yield countPendingSyncItems();\n      if (errorCount > 0) {\n        setSyncStatus(SYNC_STATUS.ERROR);\n        setSyncStatusDetails({\n          message: \"Sync completed with \" + errorCount + \" errors. \" + successCount + \" items synced successfully.\",\n          successCount: successCount,\n          errorCount: errorCount\n        });\n      } else {\n        setSyncStatus(SYNC_STATUS.SUCCESS);\n        setSyncStatusDetails({\n          message: 'Sync completed successfully',\n          successCount: successCount\n        });\n      }\n      return errorCount === 0;\n    } catch (error) {\n      console.error('Sync error:', error);\n      setSyncStatus(SYNC_STATUS.ERROR);\n      setSyncStatusDetails({\n        message: 'Sync failed',\n        error: error.message\n      });\n      return false;\n    } finally {\n      setSyncInProgress(false);\n    }\n  }), [connectionQuality, executeQuery, isAuthenticated, isConnected, isDbReady, isInternetReachable, syncInProgress, syncOnWifiOnly]);\n  var resetSyncStatus = useCallback(function () {\n    setSyncStatus(SYNC_STATUS.IDLE);\n    setSyncStatusDetails({});\n  }, []);\n  var updateSyncItem = useCallback(function () {\n    var _ref5 = _asyncToGenerator(function* (tableName, recordId, operation) {\n      var data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      if (!isDbReady) return false;\n      try {\n        var now = Date.now();\n        yield executeQuery(\"INSERT INTO sync_queue (table_name, record_id, operation, data, status, created_at, updated_at)\\n         VALUES (?, ?, ?, ?, 'pending', ?, ?);\", [tableName, recordId, operation, data ? JSON.stringify(data) : null, now, now]);\n        var newCount = pendingSyncItems + 1;\n        setPendingSyncItems(newCount);\n        yield AsyncStorage.setItem('@pending_sync_count', newCount.toString());\n        return true;\n      } catch (error) {\n        console.error('Error adding sync item:', error);\n        return false;\n      }\n    });\n    return function (_x, _x2, _x3) {\n      return _ref5.apply(this, arguments);\n    };\n  }(), [executeQuery, isDbReady, pendingSyncItems]);\n  useEffect(function () {\n    if (!isDbReady || !isAuthenticated) return;\n    var autoSync = function () {\n      var _ref6 = _asyncToGenerator(function* () {\n        if (syncInProgress) return;\n        var shouldSync = lastSyncTime === null || Date.now() - lastSyncTime > syncInterval;\n        if (shouldSync && pendingSyncItems > 0) {\n          yield syncNow();\n        }\n      });\n      return function autoSync() {\n        return _ref6.apply(this, arguments);\n      };\n    }();\n    autoSync();\n    var intervalId = setInterval(autoSync, Math.max(60000, syncInterval / 10));\n    return function () {\n      return clearInterval(intervalId);\n    };\n  }, [isDbReady, isAuthenticated, lastSyncTime, pendingSyncItems, syncInterval, syncInProgress, syncNow]);\n  var mockSyncItem = function () {\n    var _ref7 = _asyncToGenerator(function* (item) {\n      yield new Promise(function (resolve) {\n        return setTimeout(resolve, 200);\n      });\n      var success = Math.random() < 0.9;\n      return {\n        success: success\n      };\n    });\n    return function mockSyncItem(_x4) {\n      return _ref7.apply(this, arguments);\n    };\n  }();\n  return _jsx(SyncContext.Provider, {\n    value: {\n      syncStatus: syncStatus,\n      lastSyncTime: lastSyncTime,\n      pendingSyncItems: pendingSyncItems,\n      syncNow: syncNow,\n      syncStatusDetails: syncStatusDetails,\n      resetSyncStatus: resetSyncStatus,\n      updateSyncItem: updateSyncItem\n    },\n    children: children\n  });\n};","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","useCallback","AsyncStorage","AppState","useNetwork","useDatabase","useAuth","jsx","_jsx","SYNC_STATUS","IDLE","SYNCING","SUCCESS","ERROR","SyncContext","syncStatus","lastSyncTime","pendingSyncItems","syncNow","_syncNow","_asyncToGenerator","apply","arguments","syncStatusDetails","resetSyncStatus","updateSyncItem","_updateSyncItem","useSync","SyncProvider","_ref","children","_useNetwork","isConnected","isInternetReachable","connectionQuality","_useDatabase","executeQuery","transaction","isDbReady","_useAuth","isAuthenticated","_useState","_useState2","_slicedToArray","setSyncStatus","_useState3","_useState4","setSyncStatusDetails","_useState5","_useState6","setLastSyncTime","_useState7","_useState8","setPendingSyncItems","_useState9","_useState0","syncInterval","setSyncInterval","_useState1","_useState10","syncInProgress","setSyncInProgress","_useState11","_useState12","syncOnWifiOnly","setSyncOnWifiOnly","loadSyncSettings","countPendingSyncItems","_result$rows","result","rows","length","i","item","key","parseInt","value","error","console","pendingItemsCount","getItem","_result$rows2","count","setItem","toString","handleAppStateChange","nextAppState","appStateSubscription","addEventListener","remove","log","message","_pendingItems$rows","pendingItems","now","Date","successCount","errorCount","syncResult","mockSyncItem","success","id","_ref5","tableName","recordId","operation","data","undefined","JSON","stringify","newCount","_x","_x2","_x3","autoSync","_ref6","shouldSync","intervalId","setInterval","Math","max","clearInterval","_ref7","Promise","resolve","setTimeout","random","_x4","Provider"],"sources":["C:/Users/eacha/OneDrive/Desktop/SMART FARMER/FRONTEND/src/contexts/SyncContext.js"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect, useCallback } from 'react';\r\nimport AsyncStorage from '@react-native-async-storage/async-storage';\r\nimport { AppState } from 'react-native';\r\nimport { useNetwork } from './NetworkContext';\r\nimport { useDatabase } from './DatabaseContext';\r\nimport { useAuth } from './AuthContext';\r\n\r\n// Sync status types\r\nexport const SYNC_STATUS = {\r\n  IDLE: 'idle',\r\n  SYNCING: 'syncing',\r\n  SUCCESS: 'success',\r\n  ERROR: 'error',\r\n};\r\n\r\nconst SyncContext = createContext({\r\n  syncStatus: SYNC_STATUS.IDLE,\r\n  lastSyncTime: null,\r\n  pendingSyncItems: 0,\r\n  syncNow: async () => {},\r\n  syncStatusDetails: {},\r\n  resetSyncStatus: () => {},\r\n  updateSyncItem: async () => {},\r\n});\r\n\r\nexport const useSync = () => useContext(SyncContext);\r\n\r\nexport const SyncProvider = ({ children }) => {\r\n  const { isConnected, isInternetReachable, connectionQuality } = useNetwork();\r\n  const { executeQuery, transaction, isDbReady } = useDatabase();\r\n  const { isAuthenticated } = useAuth();\r\n  \r\n  const [syncStatus, setSyncStatus] = useState(SYNC_STATUS.IDLE);\r\n  const [syncStatusDetails, setSyncStatusDetails] = useState({});\r\n  const [lastSyncTime, setLastSyncTime] = useState(null);\r\n  const [pendingSyncItems, setPendingSyncItems] = useState(0);\r\n  const [syncInterval, setSyncInterval] = useState(3600000); // 1 hour default\r\n  const [syncInProgress, setSyncInProgress] = useState(false);\r\n  const [syncOnWifiOnly, setSyncOnWifiOnly] = useState(false);\r\n  \r\n  // Load sync settings\r\n  useEffect(() => {\r\n    if (isDbReady) {\r\n      loadSyncSettings();\r\n      countPendingSyncItems();\r\n    }\r\n  }, [isDbReady]);\r\n\r\n  // Load last sync time and other settings from the database\r\n  const loadSyncSettings = useCallback(async () => {\r\n    try {\r\n      // Get sync settings from the database\r\n      const result = await executeQuery(\r\n        \"SELECT key, value FROM settings WHERE key IN ('last_sync', 'sync_interval', 'sync_wifi_only');\"\r\n      );\r\n      \r\n      if (result?.rows?.length > 0) {\r\n        // Process each setting\r\n        for (let i = 0; i < result.rows.length; i++) {\r\n          const item = result.rows.item(i);\r\n          \r\n          switch (item.key) {\r\n            case 'last_sync':\r\n              setLastSyncTime(parseInt(item.value, 10) || null);\r\n              break;\r\n            case 'sync_interval':\r\n              setSyncInterval(parseInt(item.value, 10) || 3600000);\r\n              break;\r\n            case 'sync_wifi_only':\r\n              setSyncOnWifiOnly(item.value === 'true');\r\n              break;\r\n            default:\r\n              break;\r\n          }\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('Error loading sync settings:', error);\r\n    }\r\n  }, [executeQuery, isDbReady]);\r\n\r\n  // Count pending sync items\r\n  const countPendingSyncItems = useCallback(async () => {\r\n    if (!isDbReady) return;\r\n    \r\n    try {\r\n      const pendingItemsCount = await AsyncStorage.getItem('@pending_sync_count');\r\n      \r\n      if (pendingItemsCount) {\r\n        setPendingSyncItems(parseInt(pendingItemsCount, 10));\r\n      } else {\r\n        // Count from database\r\n        const result = await executeQuery(\r\n          \"SELECT COUNT(*) as count FROM sync_queue WHERE status = 'pending';\"\r\n        );\r\n        \r\n        if (result?.rows?.length > 0) {\r\n          const count = result.rows.item(0).count;\r\n          setPendingSyncItems(count);\r\n          await AsyncStorage.setItem('@pending_sync_count', count.toString());\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('Error counting pending sync items:', error);\r\n    }\r\n  }, [executeQuery, isDbReady]);\r\n\r\n  // Update sync count when app comes to foreground\r\n  useEffect(() => {\r\n    const handleAppStateChange = (nextAppState) => {\r\n      if (nextAppState === 'active') {\r\n        countPendingSyncItems();\r\n      }\r\n    };\r\n\r\n    const appStateSubscription = AppState.addEventListener('change', handleAppStateChange);\r\n    \r\n    return () => {\r\n      appStateSubscription.remove();\r\n    };\r\n  }, [countPendingSyncItems]);\r\n\r\n  // Main sync function\r\n  const syncNow = useCallback(async () => {\r\n    if (syncInProgress || !isDbReady || !isAuthenticated) return false;\r\n    \r\n    // Check if we should sync based on connection\r\n    if (syncOnWifiOnly && connectionQuality !== 'excellent') {\r\n      console.log('Sync aborted: WiFi-only mode is active and not on WiFi');\r\n      setSyncStatusDetails({\r\n        message: 'Sync requires WiFi connection',\r\n        error: 'wifi_required'\r\n      });\r\n      return false;\r\n    }\r\n    \r\n    if (!isConnected || !isInternetReachable) {\r\n      console.log('Sync aborted: No internet connection');\r\n      setSyncStatusDetails({\r\n        message: 'No internet connection',\r\n        error: 'no_connection'\r\n      });\r\n      return false;\r\n    }\r\n    \r\n    try {\r\n      setSyncInProgress(true);\r\n      setSyncStatus(SYNC_STATUS.SYNCING);\r\n      setSyncStatusDetails({ message: 'Starting synchronization...' });\r\n      \r\n      // Get all pending sync items\r\n      const pendingItems = await executeQuery(\r\n        \"SELECT * FROM sync_queue WHERE status = 'pending' ORDER BY created_at ASC LIMIT 100;\"\r\n      );\r\n      \r\n      if (pendingItems?.rows?.length === 0) {\r\n        // No items to sync\r\n        const now = Date.now();\r\n        await executeQuery(\r\n          \"UPDATE settings SET value = ?, updated_at = ? WHERE key = 'last_sync';\",\r\n          [now.toString(), now]\r\n        );\r\n        setLastSyncTime(now);\r\n        setSyncStatus(SYNC_STATUS.SUCCESS);\r\n        setSyncStatusDetails({ message: 'Sync completed successfully (no changes)' });\r\n        return true;\r\n      }\r\n      \r\n      // Process each item\r\n      let successCount = 0;\r\n      let errorCount = 0;\r\n      \r\n      // Process items based on type\r\n      for (let i = 0; i < pendingItems.rows.length; i++) {\r\n        const item = pendingItems.rows.item(i);\r\n        setSyncStatusDetails({ message: `Syncing item ${i + 1} of ${pendingItems.rows.length}` });\r\n        \r\n        try {\r\n          // In a real app, this would call the appropriate API endpoint\r\n          // This is a simplified placeholder for the actual sync logic\r\n          const syncResult = await mockSyncItem(item);\r\n          \r\n          if (syncResult.success) {\r\n            // Update item status to 'synced'\r\n            await executeQuery(\r\n              \"UPDATE sync_queue SET status = 'synced', updated_at = ? WHERE id = ?;\",\r\n              [Date.now(), item.id]\r\n            );\r\n            successCount++;\r\n          } else {\r\n            // Update attempts count\r\n            await executeQuery(\r\n              \"UPDATE sync_queue SET attempts = attempts + 1, updated_at = ? WHERE id = ?;\",\r\n              [Date.now(), item.id]\r\n            );\r\n            errorCount++;\r\n          }\r\n        } catch (error) {\r\n          console.error('Error syncing item:', item.id, error);\r\n          errorCount++;\r\n        }\r\n      }\r\n      \r\n      // Update last sync time\r\n      const now = Date.now();\r\n      await executeQuery(\r\n        \"UPDATE settings SET value = ?, updated_at = ? WHERE key = 'last_sync';\",\r\n        [now.toString(), now]\r\n      );\r\n      \r\n      // Update counters\r\n      setLastSyncTime(now);\r\n      await countPendingSyncItems();\r\n      \r\n      // Set final status\r\n      if (errorCount > 0) {\r\n        setSyncStatus(SYNC_STATUS.ERROR);\r\n        setSyncStatusDetails({\r\n          message: `Sync completed with ${errorCount} errors. ${successCount} items synced successfully.`,\r\n          successCount,\r\n          errorCount\r\n        });\r\n      } else {\r\n        setSyncStatus(SYNC_STATUS.SUCCESS);\r\n        setSyncStatusDetails({\r\n          message: 'Sync completed successfully',\r\n          successCount\r\n        });\r\n      }\r\n      \r\n      return errorCount === 0;\r\n    } catch (error) {\r\n      console.error('Sync error:', error);\r\n      setSyncStatus(SYNC_STATUS.ERROR);\r\n      setSyncStatusDetails({\r\n        message: 'Sync failed',\r\n        error: error.message\r\n      });\r\n      return false;\r\n    } finally {\r\n      setSyncInProgress(false);\r\n    }\r\n  }, [\r\n    connectionQuality,\r\n    executeQuery,\r\n    isAuthenticated,\r\n    isConnected,\r\n    isDbReady,\r\n    isInternetReachable,\r\n    syncInProgress,\r\n    syncOnWifiOnly\r\n  ]);\r\n\r\n  // Reset sync status\r\n  const resetSyncStatus = useCallback(() => {\r\n    setSyncStatus(SYNC_STATUS.IDLE);\r\n    setSyncStatusDetails({});\r\n  }, []);\r\n\r\n  // Add an item to the sync queue\r\n  const updateSyncItem = useCallback(async (tableName, recordId, operation, data = null) => {\r\n    if (!isDbReady) return false;\r\n    \r\n    try {\r\n      const now = Date.now();\r\n      await executeQuery(\r\n        `INSERT INTO sync_queue (table_name, record_id, operation, data, status, created_at, updated_at)\r\n         VALUES (?, ?, ?, ?, 'pending', ?, ?);`,\r\n        [tableName, recordId, operation, data ? JSON.stringify(data) : null, now, now]\r\n      );\r\n      \r\n      // Update pending count\r\n      const newCount = pendingSyncItems + 1;\r\n      setPendingSyncItems(newCount);\r\n      await AsyncStorage.setItem('@pending_sync_count', newCount.toString());\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error adding sync item:', error);\r\n      return false;\r\n    }\r\n  }, [executeQuery, isDbReady, pendingSyncItems]);\r\n\r\n  // Auto sync based on interval\r\n  useEffect(() => {\r\n    if (!isDbReady || !isAuthenticated) return;\r\n    \r\n    const autoSync = async () => {\r\n      // Don't auto-sync if manual sync is in progress\r\n      if (syncInProgress) return;\r\n      \r\n      // Check if we should sync based on last sync time\r\n      const shouldSync = lastSyncTime === null || \r\n                        (Date.now() - lastSyncTime) > syncInterval;\r\n      \r\n      if (shouldSync && pendingSyncItems > 0) {\r\n        await syncNow();\r\n      }\r\n    };\r\n    \r\n    // Run initial check\r\n    autoSync();\r\n    \r\n    // Set up interval\r\n    const intervalId = setInterval(autoSync, Math.max(60000, syncInterval / 10)); // Check at most once per minute\r\n    \r\n    return () => clearInterval(intervalId);\r\n  }, [isDbReady, isAuthenticated, lastSyncTime, pendingSyncItems, syncInterval, syncInProgress, syncNow]);\r\n\r\n  // Mock function to simulate syncing with server\r\n  const mockSyncItem = async (item) => {\r\n    // Simulate network delay\r\n    await new Promise(resolve => setTimeout(resolve, 200));\r\n    \r\n    // Simulate 90% success rate\r\n    const success = Math.random() < 0.9;\r\n    \r\n    return { success };\r\n  };\r\n\r\n  return (\r\n    <SyncContext.Provider\r\n      value={{\r\n        syncStatus,\r\n        lastSyncTime,\r\n        pendingSyncItems,\r\n        syncNow,\r\n        syncStatusDetails,\r\n        resetSyncStatus,\r\n        updateSyncItem,\r\n      }}\r\n    >\r\n      {children}\r\n    </SyncContext.Provider>\r\n  );\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}